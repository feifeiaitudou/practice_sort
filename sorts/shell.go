package sorts

//不稳定
//中等规模效率较高,在插入排序的基础上的优化版本
//平均时间复杂度n^1.3
//对需要排序的数据进行一定间隔的分组,分组之间进行插入排序
//然后不断的缩小间隔,直到间隔等于1,此时相当于进行插入排序(现在的序列已经基本有序了)
//效率较高的原因: 大分组时,移动元素少; 小分组时,移动距离短
// []int{8, 21, 3, 4, 5, 6}
//交换不相邻的元素
//步长数(间隔大小) == 最终分成的序列数的大小,如果间隔为4,则分为4组
func ShellSort(data []int) {
	//计算分组间隔,现在先按照长度的一半进行分组

	//间隔的计算方式可以有多种,这里直接就取出一半(间隔必须小于序列长度,并且最终能到1)
	for h := len(data) / 2; h >= 1; h /= 2 {
		//一次的距离的全部序列完成之后,缩短距离 (当前为缩短一半)

		//多个序列之间进行插入排序,每一次从序列的第一个开始
		/*for i := 0; i < len(data); i += h {
			//这样能够保证每一次读取的元素都是相同序列的元素
			for j := i; j > 0; j -= h {
				//对每个序列组进行插入排序,每次的移动位置为一个距离
				if data[j] < data[j-h] {
					data[j], data[j-h] = data[j-h], data[j]
				}
			}
		}*/

		//上面不能从0开始,这样不能对每个序列进行插入排序,最终为对间隔为1的场景进行排序
		// if h > 1 {
		//			continue
		//}

		//循环操作每个序列,关键:能够正常获取到每个序列的开始位置
		for i := 1; i <= h; i++ {
			//对每个子序列进行循环

			for j := i - 1; j < len(data); j += h {
				//j := i - 1,获取到了每个子序列的起始位置
				//每个子序列的开始位置为0,1,2,3....h-1

				for k := j; k > 0; k -= h {

					if k-h < 0 {
						//如果结果小于0,则表示开始处理子序列的第一个元素
						continue
					}

					if data[k] < data[k-h] {
						//需要插入
						data[k], data[k-h] = data[k-h], data[k]
					}
				}
			}
		}
	}

}
