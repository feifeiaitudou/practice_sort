package sorts

//不稳定
//中等规模效率较高,在插入排序的基础上的优化版本
//平均时间复杂度n^1.3
//对需要排序的数据进行一定间隔的分组,分组之间进行插入排序
//然后不断的缩小间隔,直到间隔等于1,此时相当于进行插入排序(现在的序列已经基本有序了)
//效率较高的原因: 大分组时,移动元素少; 小分组时,移动距离短
// []int{8, 21, 3, 4, 5, 6}
func ShellSort(data []int) {
	for step := len(data) / 2; step > 0; step /= 2 {
		//第一层循环,更新每个分组的元素(计算分组的距离,直到最后为1)

		for i := step; i < len(data); i++ { //得到 4 5 6
			//第二层循环, 从第一个分组位置开始,向后移动,

			for j := i - step; j >= 0; j -= step { // 得到8 21 3

				//对于这里的j -= step的理解:
				//我之前对于希尔的分组理解有误,不是每个分组只有两个元素,分组的元素个数为>=1个
				//j -= step正好能把每个分组的元素对应获取到

				//第三层循环,每个分组的第一个元素

				if data[j+step] > data[j] {
					//每个分组的第二个元素与第一个元素比较
					data[j], data[j+step] = data[j+step], data[j]
				}
			}
		}
	}

}
